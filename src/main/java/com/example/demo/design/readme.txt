面向对象编程，并不是类越多越好，类的划分是为封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类
------------------------
策略模式：定义了算法家族，分别封装起来，让它们可以相互替换，此模式让算法的变化不会影响到使用算法的客户

策略模式是一种定义一系列算法的方法，从概念上说，这些算法都是完成了相同的工作，只是实现不同，它可以用相同的方式调用所有的算法，
减少了各种算法类与使用算法类之间的耦合
策略模式的strategy类层次为context提供了一系列的可供重用的算法或行为，继承有助于提取出这些算法的公共功能。
简化了单元测试，每个算法都有自己的实现类

策略模式封装了变化
策略模式就是为了封装算法，但在实际使用中，我们发现可以用它来封装任何类型的规则，只要在分析过程中听到需要在不同时间使用
不同的业务规则，就可以使用策略模式

-------------------------------
单一职责原则：针对一个类而言，应该只有一个引起它变化的原因

依赖倒置原则：高层模块不应该依赖底层模块，两者都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象

里氏替换原则：子类型必须能够替换掉它们的父类型

迪米特法则（最少知道原则):如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果一个类
想要调用另一个类的某一个方法的话，可以通过第三个转发这个调用。
强调在类的结构设计上，每一个类都应当尽量降低成员的访问权限。强调类之间的松耦合，类之间的耦合越弱，越有利于
复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及


-------------------------------
装饰模式：动态的给一个对象添加额外的职责，就增加功能而言，装饰模式比子类更加灵活
装饰模式是为已有功能动态的添加更多功能的一种方式。

装饰模式的优点是把类中的装饰功能从类中搬移去除，这样可以简化原有的类。有效的把类中的核心职责和装饰功能分开了，
而且可以去除相关类中重复的装饰逻辑。

建造者模式要求构建的过程必须是稳定的

------------------------------
代理模式：为其他对象提供一种代理以控制对这个对象的访问

-----------------------------
简单工厂模式的最大优点就是在工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态的实例化相关的类，
对于客户端来说，去除了具体产品的依赖。但是每次有新功能是需要修改工厂类，违背了开闭原则（可以扩展，但不能修改）

工厂方法模式：定义一个创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到子类
工厂方法模式实现时，需要客户端来决定具体实例化哪一个工厂来实现运算类，选择判断的问题还是存在的。
也就是说，工厂方法把简单工厂内部的判断逻辑移到了客户端代码来进行。想要增加功能，本来是要改工厂类的，现在是
修改客户端

工厂方法模式是简单工厂的进一步抽象和推广

---------------------------------
原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。其实就是从一个对象再创建另一个可定制
的对象，而且不需要知道任何创建对象的细节。
注意深拷贝和浅拷贝

---------------------------------
模板方法模式：定义了一个操作中算法的骨架，而将一些具体步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的
情况下重新定义该算法的某些特定步骤。
把不变行为搬到超类，去除子类中的重复代码

---------------------------------
外观模式：为子系统中一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得子系统更加容易使用

---------------------------------
建造者模式(生成器模式):将一个复杂的对象构建和表示分离，使得同样的构建过程可以创建不同的表示。
如果我们使用了建造者模式，那么用户就只需指定需要建造的类型就可以得到他们，而具体建造的过程和细节是无需知道的
对象内部构建间的构造顺序是稳定的，但对象内部的构建通常面临着复杂的变化。

建造者模式是在当创建复杂对象的算法(指挥者实现)应该独立于该对象的组成部分以及它们的装配方式时使用的模式。
---------------------------------
观察者模式(发布/订阅模式):定义了一种一对多的依赖关系，让多个观察者同时监听某一个主题对象，这个主题对象在
状态发生变化时，会通知所有观察者对象，使他们能够自动更新自己。

观察者模式所做的工作就是解除耦合，让耦合的双方都依赖于抽象，而不是依赖于具体，从而使的各自的变化都不会影响到
另一边的变化。
缺点:观察者必须实现相同的接口(如update)，可以通过事件委托的方式修改，引用Function函数

---------------------------------
